<Project>

  <Import Project="$(MSBuildThisFileDirectory)..\Directory.Build.targets" />

  <!--
    Command-line options (default = disabled, to enable /p:XXX=true):
    - PrintSettings   Enable target PrintSettingsBeforeCompile?

    Development-only options. To prevent any accident, they are ignored when
    Configuration is set to Release.
    - PatchEquality
    - PlainLinq
  -->

  <Import Project="$(MSBuildThisFileDirectory)Retail.props"
          Condition=" '$(Configuration)' == 'Release' and '$(IsPackable)' == 'true' " />

  <!-- Compiler symbols (development-only) -->
  <PropertyGroup Condition=" '$(Configuration)' != 'Release' ">
    <DefineConstants Condition=" '$(PatchEquality)' == 'true' ">$(DefineConstants);PATCH_EQUALITY</DefineConstants>
    <DefineConstants Condition=" '$(PlainLinq)' == 'true' ">$(DefineConstants);PLAIN_LINQ</DefineConstants>
  </PropertyGroup>

  <!-- Source Link -->
  <PropertyGroup>
    <!--
      We enable Source Link when ContinuousIntegrationBuild = true which, for us,
      means that we request the build to be deterministic.
      When one sets EnableSourceLink to true manually while, at the same time,
      ContinuousIntegrationBuild = false, we ensure that the local build is
      deterministic too; see DeterministicSourcePaths below.
      This differs from the usual workflow where one always references Source
      Link, then sets ContinuousIntegrationBuild to true in order to ensure a
      deterministic build.
    -->
    <EnableSourceLink>false</EnableSourceLink>
    <!-- For CI builds, the default behaviour is to have Source Link on -->
    <EnableSourceLink Condition=" '$(ContinuousIntegrationBuild)' == 'true' ">true</EnableSourceLink>

    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
    <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
    <AllowedOutputExtensionsInPackageBuildOutputFolder>$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb</AllowedOutputExtensionsInPackageBuildOutputFolder>

    <!--
      DO NOT REMOVE, it ensures deterministic outputs when building locally.
      This fixes the case where ContinuousIntegrationBuild = false and
      EnableSourceLink = true. For instance,
      > dotnet.exe build /p:EnableSourceLink=true
      then the PDB files still use local paths for the generated files.
      IMPORTANT: this is a rather unusual situation. It should only happen when
      using a build script and certainly not when using VS, otherwise the debugger
      wouldn't be able to locate the source files.
      This is not necessary when ContinuousIntegrationBuild = true. Indeed,
      Deterministic = true (default) and ContinuousIntegrationBuild = true
      imply DeterministicSourcePaths = true; see
      https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/MSBuildTask/Microsoft.Managed.Core.targets#L131
    -->
    <DeterministicSourcePaths Condition=" '$(EnableSourceLink)' == 'true' ">true</DeterministicSourcePaths>
  </PropertyGroup>
  <ItemGroup Condition=" '$(EnableSourceLink)' == 'true' ">
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="1.0.0" PrivateAssets="All" />
  </ItemGroup>
  <ItemGroup Condition=" '$(EnableSourceLink)' == 'false' ">
    <!--
      DO NOT REMOVE. Even if the default behaviour is to have Source Link on
      for CI builds, this can still be overriden from the command-line.
      dotnet.exe fails complaining about SourceRoot if ContinuousIntegrationBuild
      is set to true:
        "SourceRoot items must include at least one top-level (not nested) item
        when DeterministicSourcePaths is true"
      When we import Microsoft.SourceLink.GitHub, this is unnecessary since
      Source Link automatically adds GitHub to SourceRoot.
      Should be OK with the next NuGet's version as it will add NuGetPackageRoot
      to SourceRoot (only if IsPackable = true?).
      See https://github.com/dotnet/sdk/issues/11105,
      fixed by https://github.com/NuGet/NuGet.Client/pull/3430
      See also https://github.com/dotnet/sourcelink/issues/91
    -->
    <SourceRoot Include="$(RepositoryRoot)" Condition=" '$(ContinuousIntegrationBuild)' == 'true' " />
  </ItemGroup>
  <Target Name="CoverletGetPathMap"
          DependsOnTargets="InitializeSourceRootMappedPaths"
          Returns="@(_LocalTopLevelSourceRoot)"
          Condition=" '$(DeterministicSourcePaths)' == 'true' ">
    <!-- Fix for Coverlet + SourceLink + Determinism when ContinuousIntegrationBuild = true -->
    <ItemGroup>
      <_LocalTopLevelSourceRoot Include="@(SourceRoot)" Condition=" '%(SourceRoot.NestedRoot)' == '' " />
    </ItemGroup>
  </Target>

  <!-- FxCop analyzers -->
  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers" Version="3.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <!-- Target for verbose settings -->
  <Target Name="PrintSettingsBeforeCompile" BeforeTargets="Compile"
          Condition=" '$(PrintSettings)' == 'true' and '$(TargetFramework)' != '' ">
    <PropertyGroup>
      <_MyMessage>| %24(ApiProfileMoniker)          = "$(ApiProfileMoniker)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(vNext)                      = "$(vNext)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(VisibleInternals)           = "$(VisibleInternals)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(SignAssembly)               = "$(SignAssembly)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(ContinuousIntegrationBuild) = "$(ContinuousIntegrationBuild)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(EnableSourceLink)           = "$(EnableSourceLink)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(DeterministicSourcePaths)   = "$(DeterministicSourcePaths)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(CheckForOverflowUnderflow)  = "$(CheckForOverflowUnderflow)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(DebugType)                  = "$(DebugType)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(NoWarn)                     = "$(NoWarn)"</_MyMessage>
      <_MyMessage>$(_MyMessage)%0A| %24(DefineConstants) = "$(DefineConstants)"</_MyMessage>
    </PropertyGroup>

    <Message Text="+ $(AssemblyName) for $(TargetFramework)%0A$(_MyMessage)" Importance="high" />
  </Target>

</Project>

TODO
====

Code
----

- Add overloads w/ IEqualityComparer<T> (true structural comparison).
- LINQ: optimize, more. "Monadic" LINQ. Output Maybe<IEnumerable<T>> and LINQ ops.
- Async Enumerable.
- Serialization (XML).
- Localise error messages (ExceptionFactory)?
- FIXME, TODO and REVIEW within the code.
- PURE_MAYBE?

Tools / Build System
--------------------

- pack.ps1, ContinuousIntegrationBuild=true? Extra Git tests (synched?).
  Option -Official -Yes (not -Freeze): add a warning when we update the cache.
  Rework test-package.ps1 (vNext, official, remote).
- Roslyn Analyzer:
  * Of(), Flatten(). Squash(Maybe<T?>) where T : class
  * SelectMany(), ZipWith(), Bind().
- Perf tool (LINQ, nulls, iterable), .NET Core tool for benchmarkdotnet.
- MSBuild/NuGet in "test": RestoreSources, RestoreAdditionalProjectSources,
  RestorePackagesPath and RestoreFallbackFolders.
  See also RestorePackagesWithLockFile, RestoreLockedMode, etc.
  https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets
  https://github.com/NuGet/Home/issues/6045
- Multi-targeting with non-Windows OSes, MSBuild, scripts, CI.
  * path separator, filename casing.
  * many script helpers only make sense or work on Windows.
  * $([MSBuild]::EnsureTrailingSlash('$(PathProperty)'))
  * see Xunit website which contains some useful infos.

Testing
-------

Testing is well underway but there is still a lot to be done.
Fix naming schema, split tests, more functional tests.

- MaybeComparer<T>, proper testing of equality and ordering comparisons.
  Expand comparison tests (order and equality). See NONGENERIC_MAYBE
  Structural comparisons w/ structural types.
  https://stackoverflow.com/questions/4968580/why-arent-istructuralequatable-and-istructuralcomparable-generic
- Maybe<Func<>>
- delegates that return null.

Documentation
-------------

XML comments with complete examples.
Help: https://github.com/dotnet/dotnet-api-docs/wiki
When done, configure Abc.Maybe to warn on missing XML comments.

Sample code w/ C#, VB and F# (compare to F# option types).

A bit of marketing, compare to other option types.

"Lifted" comparison T w/ Maybe<T> to handle mixed type, eg Maybe<int?>,
Maybe<int>, int? and int. See custom MaybeComparer<T>. Do not implement
IEquatable<T> (T == Maybe<T>), IComparable<T> this would be misleading?

Struct really? Explain and compare to ValueTuple.
- https://docs.microsoft.com/en-gb/dotnet/csharp/tuples
- http://mustoverride.com/tuples_structs/
- https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/june/csharp-tuple-trouble-why-csharp-tuples-get-to-break-the-guidelines
- https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/value-options
- https://github.com/fsharp/fslang-design/blob/master/FSharp.Core-4.5.0.0/FS-1057-valueoption.md

Nullable attributes and notnull constraint.
It would make a lot of sense to add a notnull constraint on the T of Maybe<T>,
but it worries me a bit (I need to gain more experience with the new NRT). It
would allow to warn a user trying to create a Maybe<int?> or a Maybe<string?>.
- https://docs.microsoft.com/en-us/dotnet/csharp/nullable-attributes
- https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/
- https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/
- https://devblogs.microsoft.com/dotnet/embracing-nullable-reference-types/

CI
--

AZP: I'm really tempted to abandon DotNetCoreCLI@2 and use "script" instead,
much simpler, much clearer and without all the inconsistencies that come with
the Azure task. One exception is for testing since the task automatically
publishes the test results.

GitHub actions: use global.json.

Tracing: DOTNET_CLI_CAPTURE_TIMING, COREHOST_TRACE.

NuGet caching (AZP)?
<PropertyGroup Condition=" $(ContinuousIntegrationBuild) == 'true' ">
  <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  <RestoreLockedMode>true</RestoreLockedMode>
  <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
  <!--<NoWarn>NU1603</NoWarn>-->
</PropertyGroup>

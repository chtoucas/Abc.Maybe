TODO
====

Towards version 1.0.0
---------------------

Currently, the only thing blocking us for a 1.0.0 release is proper testing of
equality and ordering comparisons.
- Testing is well underway but there is still a lot to be done.
  * Split tests.
  * More functional tests.
  * Expand comparison tests (order and equality).
    See NONGENERIC_MAYBE
    Structural comparisons w/ structural types.
    https://stackoverflow.com/questions/4968580/why-arent-istructuralequatable-and-istructuralcomparable-generic
  * Maybe<Func<>>
  * delegates that return null.
- Check published packages (upgrade, debugging experience).
- Add #nullable enable at the top of each PublicAPI.*.txt file.

Multitargeting: target net461/netstandard1.0.
- We use TargetFrameworkIdentifier ('.NETFramework') and NETFRAMEWORK instead
  of TargetFramework and NET461, is it such a good idea?
- Packaging: net461 -> no full pdb...
  https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if
- https://github.com/dotnet/announcements/issues/31
- code coverage?
- Build warning NU1701 (should be OK now)
  https://docs.microsoft.com/en-us/dotnet/core/porting/third-party-deps#net-framework-compatibility-mode
  https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files

Documentation (README)
- A bit of marketing, compare to other option types.
- Struct really? Explain and compare to ValueTuple.
  https://docs.microsoft.com/en-gb/dotnet/csharp/tuples
  http://mustoverride.com/tuples_structs/
  https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/june/csharp-tuple-trouble-why-csharp-tuples-get-to-break-the-guidelines
  https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/value-options
  https://github.com/fsharp/fslang-design/blob/master/FSharp.Core-4.5.0.0/FS-1057-valueoption.md
- Nullable attributes and notnull constraint.
  It would make a lot of sense to add a notnull constraint on the T of Maybe<T>,
  but it worries me a bit (I need to gain more experience with the new NRT). It
  would allow to warn a user trying to create a Maybe<int?> or a Maybe<string?>.
  https://docs.microsoft.com/en-us/dotnet/csharp/nullable-attributes
  https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/
  https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/
  https://devblogs.microsoft.com/dotnet/embracing-nullable-reference-types/
- https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets

vNEXT
-----

- Add overloads w/ IEqualityComparer<T> (true structural comparison).
- "Lifted" comparison T w/ Maybe<T> to handle mixed type, eg Maybe<int?>,
  Maybe<int>, int? and int. This should be a custom MaybeComparer<T>. Do not
  implement IEquatable<T> (T == Maybe<T>), IComparable<T> this would be misleading?
- More May helpers w/ Span<T>.
- LINQ: optimize, more ops.
  "Monadic" LINQ. Output Maybe<IEnumerable<T>> and LINQ ops.
- Utilities to write code in the ROP style (Railway Oriented Programming).
- Extensions.
- Async (configurable, enumerable).
- Roslyn Analyzer:
  * Of(), Flatten(). Squash(Maybe<T?>) where T : class
  * SelectMany(), ZipWith(), Bind().
- Serialization (XML)

Main tasks
- FIXME, TODO and REVIEW within the code.
- XML comments with complete examples.
  https://github.com/dotnet/dotnet-api-docs/wiki
  When done, filter out Abc.Maybe in Directory.Build.targets (NoWarn), and add
  <NoWarn /> for Retail builds?
- Localise user messages (ExceptionFactory)?

Other tasks
- Naming tests: explain rules in this doc and fix the tests themselves if necessary.
- Perf tool (LINQ, nulls, iterable).
- Sample code w/ C#, VB and F#.
- BannedApiAnalyzers?
- Deterministic build? Disabled as it seems to conflict with the fact that we
  change the assembly file version and the description on every build.
- SourceLink? Right now, the answer is no as it requires that the customer changes
  a few VS settings. We use embbeded symbols as it seems to work all the time
  (apparently there are situations where a separate pdb can cause problems too);
  one drawback is the increased size of the dll (~8 Ko).
  If we do change our mind, remove AllowedOutputExtensionsInPackageBuildOutputFolder,
  no longer set InformationalVersion (generated by SourceLink?), add
  ContinuousIntegrationBuild.
  https://github.com/NuGet/Home/issues/4142
  https://github.com/clairernovotny/DeterministicBuilds
- Replace coverlet.msbuild by coverlet-console? Use runsettings.
  Add coverlet.collector to the test project. Coverity?
- Publish dev packages to myget or github?
- Cleanup scripts, dotnet nuget locals --clear all.
- Local tools: find updates, dotnet-outdated.
  Remove refs to OpenCover and ReportGenerator in Abc.Tests.
  https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools

TODO
====

Issues
------

azure-pipelines-test-pack.yml picks up the package from NuGet.org.
  Is it OK now?

External issues?
- NuGet Package:
  * Compiler Flags <--- requires MSBuild 16.7p3+
  * PDB type = full, it should be "pdbonly" <--- hard-coded in NPE.
- Code Coverage. When multi-targeting rg reports 100% CC even if it's not the
  case for one of the targets.

Code
----

- Add overloads w/ IEqualityComparer<T> (true structural comparison).
- LINQ: optimize, more. "Monadic" LINQ. Output Maybe<IEnumerable<T>> and LINQ ops.
- Async Enumerable.
- Serialization (XML).
- Localise error messages (ExceptionFactory)?
- FIXME, TODO and REVIEW within the code.

Tools / Build System
--------------------

- VS: ability to temporarily set SmokeBuild to false.
- MSBuild/NuGet in "test": RestoreSources, RestoreAdditionalProjectSources,
  RestorePackagesPath and RestoreFallbackFolders.
  https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets
  https://github.com/NuGet/Home/issues/6045
- Multi-targeting with non-Windows OSes, MSBuild, scripts, CI.
  * paths, casing
  * see Xunit website which contains some useful infos.
    <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' ">
      <Reference Include="System.Runtime" />
    </ItemGroup>
- EnableSourceLink no longer prevents coverlet to run, but it fails when we set
  UseSourceLink=true (see cover.ps1 & coverlet.runsettings). All paths are still
  local too.
- Scripts
  * Add option -Verbosity?
  * Add option -MyVerbose to test-package.ps1.
  * Verbosity tweak for "dotnet test": -v minimal /p:PrintSettings=true
    does nothing with a test project. When resolved, update AZP.
  * test-package.ps1, if a version is not cached, ask if we want to create it.
- Roslyn Analyzer:
  * Of(), Flatten(). Squash(Maybe<T?>) where T : class
  * SelectMany(), ZipWith(), Bind().
- Perf tool (LINQ, nulls, iterable), .NET Core tool for benchmarkdotnet.

Testing
-------

Testing is well underway but there is still a lot to be done.
Fix naming schema, split tests, more functional tests.

- MaybeComparer<T>, proper testing of equality and ordering comparisons.
  Expand comparison tests (order and equality). See NONGENERIC_MAYBE
  Structural comparisons w/ structural types.
  https://stackoverflow.com/questions/4968580/why-arent-istructuralequatable-and-istructuralcomparable-generic
- Maybe<Func<>>
- delegates that return null.

Documentation
-------------

XML comments with complete examples.
Help: https://github.com/dotnet/dotnet-api-docs/wiki
When done, configure Abc.Maybe to warn on missing XML comments.

Sample code w/ C#, VB and F# (compare to F# option types).

A bit of marketing, compare to other option types.

"Lifted" comparison T w/ Maybe<T> to handle mixed type, eg Maybe<int?>,
Maybe<int>, int? and int. See custom MaybeComparer<T>. Do not implement
IEquatable<T> (T == Maybe<T>), IComparable<T> this would be misleading?

Struct really? Explain and compare to ValueTuple.
- https://docs.microsoft.com/en-gb/dotnet/csharp/tuples
- http://mustoverride.com/tuples_structs/
- https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/june/csharp-tuple-trouble-why-csharp-tuples-get-to-break-the-guidelines
- https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/value-options
- https://github.com/fsharp/fslang-design/blob/master/FSharp.Core-4.5.0.0/FS-1057-valueoption.md

Nullable attributes and notnull constraint.
It would make a lot of sense to add a notnull constraint on the T of Maybe<T>,
but it worries me a bit (I need to gain more experience with the new NRT). It
would allow to warn a user trying to create a Maybe<int?> or a Maybe<string?>.
- https://docs.microsoft.com/en-us/dotnet/csharp/nullable-attributes
- https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/
- https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/
- https://devblogs.microsoft.com/dotnet/embracing-nullable-reference-types/

CI
--

AZP: I'm really tempted to abandon DotNetCoreCLI@2 and use "script" instead,
much simpler, much clearer and without all the inconsistencies that come with
the Azure task. One exception is for testing since the task automatically
publishes the test results.

Explicit set the nuget.config when calling "dotnet restore"?

GitHub actions: use global.json.

NuGet caching (AZP)?
<PropertyGroup Condition=" $(ContinuousIntegrationBuild) == 'true' ">
  <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
  <RestoreLockedMode>true</RestoreLockedMode>
  <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
  <!--<NoWarn>NU1603</NoWarn>-->
</PropertyGroup>

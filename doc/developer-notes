Developer Notes
===============

Minimal requirement: .NET Core 3.1.300

Versioning
----------

Format Major.Minor.Patch[-PreRelease]
- Major: Breaking changes -or- Major new features.
- Minor: Minor new features, but backwards compatible.
- Patch: Backwards compatible bug fixes only.
- PreRelease:
  alpha) Used for work-in-progress and experimentation.
  beta)  One that is feature complete for the next planned release, but may
         contain known bugs.
  rc)    A release that's potentially final (stable) unless significant bugs
         emerge.
Regarding new features, we do not follow exactly semantic versioning;
see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning

Under normal circumstances, we do NOT introduce breaking changes, in particular
we do NOT remove features (we mark them as obsolete).
If we have to, this can ONLY happen with a new MAJOR release (not minor), eg
1.3.4 to 2.0.0 is OK, but 1.3.4 to 1.4.0 is NOT.
Pre-releases are free to introduce new features and remove them after; it should
not happen with beta releases but we never know.

Changelog
---------

Sections.
- Changes.
  Binary breaking changes MUST be prefixed w/ [BREAKING] and appear first.
  Removed features MUST be prefixed w/ [REMOVED] and appear just after.
  NB: any item appearing here obviously introduces a breaking change.
  Obsolete methods MUST be prefixed w/ [OBSOLETE].
- Fixes, for any bug fixes.
- Security, in case of vulnerabilities.
- Internal changes, for changes that are of no interest outside the project.

Production releases should have a title and highlight the relevant changes made
during the pre-release phase.

References.
- https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/breaking-changes
- https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/breaking-change-rules.md
- https://stackoverflow.com/questions/1456785/a-definitive-guide-to-api-breaking-changes-in-net

Release Process
---------------

Requirement: command-line git.

Before a production packages, check that there are no remaining FIXMEs and review
the TODOs and REVIEWs.

Pre action, for beta -or- production packages.
0. Run script eng\freeze-api.ps1, then review the result.
   NB: between releases, feel free to add and remove **new** stuff.

1. New version in src\Abc.Maybe.props
2. Update CHANGELOG
3. Run eng\pack.ps1 -NoCI -Force -y       Create the package
4. Run eng\test-package.ps1 -NoCI -a -y   Test the result
6. Git commit ("Change version number")
7. Run script eng\pack.ps1 -Freeze        Recreate, and maybe publish the package
8. Publish package                        Only if not yet done

Post actions.
a. For production packages, git tag, then publish.
   > git tag vX.Y.Z
   or
   > git tag -a vX.Y.Z -m "Bla bla"
   then
   > git push origin vX.Y.Z
   Or do it within GitHub website.
   https://git-scm.com/book/en/v2/Git-Basics-Tagging
b. Update the page Releases on github.

Multi-targeting
---------------

Inside VS, we only use .NET Standard 2.0 and .NET Core 3.1 (see D.B.props).

IMPORTANT, after adding or removing a framework, if necessary, update the
top-level D.B.props and D.B.targets. Be sure to update "azure-pipelines.yml" too.

API differences. We try to minimize them by defining only two "profiles" that
match exactly a .NET Standard version:
- Profile 2.1 for .NET Standard 2.1.
- Profile 2.0 for for the platforms preceding it.
Profile 2.1 is a superset of Profile 2.0.
NB: attributes are NOT considered to be part of the API.

If there are, for say, things we could do w/ .NET Standard 2.1 but not w/
.NET Core 3.1, we have two cases:
- Use PlatformNotSupportedException for things that could be supported within in
  a given profile but are not actually.
- Simply do not do it if it can't be done, eg when a type would appear in the
  signature of a method only exists in one of the two platforms. This is
  actually what we do with Unit and the profile 2.0, we could support
  IEquatable<ValueTuple> but we don't because of ValueTuple.
  I could have added a dependency on System.ValueTuple (NuGet), but I prefer
  not to. I really do not want to add any dependency to our NuGet package.

Compiler Symbols
----------------

In "D.B.targets".
- NETSTANDARD1_x
- NETCOREAPP2_x
- API_PROFILE_21
- CONTRACTS_FULL (standard symbol)

In "src\D.B.targets".
- SIGNED_ASSEMBLY
- INTERNALS_VISIBLE_TO
- UNCHECKED
- PATCH_EQUALITY

Project-specific symbols.
- VISIBLE_INTERNALS         in Abc.Maybe
- USE_ATTRS_FROM_ABC_MAYBE  in Abc.Testing
- BENCHMARK_HARNESS         in Abc.Performance.Tests

Development
-----------

Rules.
- Seal classes unless they are designed for extensibility.
- Add nullable annotations wherever necessary.
  Tag any use of the null-forgiving operator (!) with BONSANG!.
- Methods that return something should have the attribure Pure. It is not
  mandatory but it clearly states that the result should not be ignored.
  It might seem superfluous, but "Ã§a ne mange pas de pain".
- Good principles worth remembering: The Zen of Python.
  https://www.python.org/dev/peps/pep-0020/

Changes to the default editor config (does not affect the compilation).
- IDE0039 - csharp_style_pattern_local_over_anonymous_function
- IDE0060 - dotnet_code_quality_unused_parameters, (Remove unused parameter) covered by CA1801.
https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-language-conventions?view=vs-2019

From time to time, we should review our usage of
- #pragma warning disable
- #nullable disable
- SuppressMessage
- BONSANG! null-forgiving ("damnit") operator

Useful tools.
- NuGet Package Explorer
- ILDasm, ILSpy, dotPeek

Build & Pack
------------

MSBuild project files are __read__ in the following order:
1. Directory.Build.props
2. XXX.csproj
3. Directory.Build.targets
4. src\Directory.Build.targets
5. Retail.props (maybe)
6. XXX.props    (maybe)
7. src\XXX\Directory.Build.targets

Source Link.
We don't create a seperate symbols package. The PDB's are rather small, and it
works all the time (no need to configure the NuGet.org symbol server in VS).

Deterministic builds?
There are many side factors to take into account to ensure identical outputs
across compilations. For instance, the cwd may change depending on the build
machine. Anyway, deterministic build is the default MSBuild setting, and we
only check that NuGetPackageExplorer reports the package as deterministic.
Furthermore, we ensure that there are no uncommited changes before creating a
package.

One thing that is definitely non-deterministic is the attribute
"AssemblyFileVersion" as it may contain build/revision numbers that
are time-dependent, but this is entirely done prior to compilation, and therefore
can be easily reproduced afterwards.

References.
- https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink
- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/deterministic-compiler-option
- https://blog.paranoidcoding.com/2016/04/05/deterministic-builds-in-roslyn.html

Tools
-----

Common script/function parameters:
   -NoCI
   -Reset
   -Restore
   -DryRun
   -Force
-f|-Platform
-c|-Configuration
-a|-AllXXX
-l|-ListXXX
-o|-Optimise
-y|-Yes
-v|-MyVerbose
-h|-Help

Common function parameters:
   -ExitOnError

Maintenance
-----------

> dotnet restore
> dotnet list package --outdated
> dotnet list eng\NETFxTools package --outdated

.NET Framework tools (see "eng\NETFxTools"):
- OpenCover, used by cover.ps1
- xunit.runner.console, used by test-package.ps1

.NET Core (local) tools:
- ReportGenerator, used by cover.ps1
- SourceLink, not used by any script

There seems to be no built-in way to find outdated .NET Core tools, but
> dotnet tool update <packagename>
updates the tool with the latest stable version.
To find the <packagename>:
> dotnet tool list
Right now, we only have to do:
> dotnet tool update dotnet-reportgenerator-globaltool

To find outdated NuGet references in supporting projects:
> dotnet list test\NETSdk package --framework net48 --outdated
NB: these commands will fail if the package were not restored before.
NB: we used net48, but any other would do the job (and you can remove this).
NB: Project test\Blank has no external references.

Show / clear content of NuGet cache
> dotnet nuget locals all -l
> dotnet nuget locals all --clear

Strong named key
----------------

To extract the public key, then get the public key.
> sn -p Abc.snk Abc.pk
> sn -tp Abc.pk

Developer Notes
===============

Minimal requirement: .NET Core 3.1.300

See also "src\Abc.Tests\README" and "test\README".

- Versioning
- Changelog
- Release Process
- Multi-targeting
- Compiler Symbols
- Development
- Build
- CI
- PowerShell
- Maintenance
- Misc

Versioning
----------

Format Major.Minor.Patch[-PreRelease]
- Major: Breaking changes -or- Major new features.
- Minor: Minor new features, but backwards compatible.
- Patch: Backwards compatible bug fixes only.
- PreRelease:
  alpha) Used for work-in-progress and experimentation.
  beta)  One that is feature complete for the next planned release, but may
         contain known bugs.
  rc)    A release that's potentially final (stable) unless significant bugs
         emerge.
Regarding new features, we do not follow exactly semantic versioning;
see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning

Under normal circumstances, we do NOT introduce breaking changes, in particular
we do NOT remove features (we mark them as obsolete).
If we have to, this can ONLY happen with a new MAJOR release (not minor), eg
1.3.4 to 2.0.0 is OK, but 1.3.4 to 1.4.0 is NOT.
Pre-releases are free to introduce new features and remove them after; it should
not happen with beta releases but we never know.

Changelog
---------

Sections.
- Changes.
  Binary breaking changes MUST be prefixed w/ [BREAKING] and appear first.
  Removed features MUST be prefixed w/ [REMOVED] and appear just after.
  NB: any item appearing here obviously introduces a breaking change.
  Obsolete methods MUST be prefixed w/ [OBSOLETE].
- Fixes, for any bug fixes.
- Security, in case of vulnerabilities.
- Internal changes, for changes that are of no interest outside the project.

Production releases should have a title and highlight the relevant changes made
during the pre-release phase.

References.
- https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/breaking-changes
- https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/breaking-change-rules.md
- https://stackoverflow.com/questions/1456785/a-definitive-guide-to-api-breaking-changes-in-net

Release Process
---------------

Requirement: command-line git.

WARNING: should be done on a Windows box, otherwise DebugType will always be
equal to "portable".

Before a production packages, check that there are no remaining FIXMEs and
review the TODOs and REVIEWs.

Steps 3 and 4 are optional, instead one can simply check the CI results.

Pre action, for beta -or- production packages.
0. Run script eng\freeze-api.ps1, then review the result.
   NB: between releases, feel free to add and remove **new** stuff.

1. New version in src\Abc.Maybe.props
2. Update CHANGELOG
3. (optional) Run eng\pack.ps1 -NoDEV -Force -y      Create the package
4. (optional) Run eng\test-package.ps1 -NoDEV -a -y  Test the result
6. Git commit ("Change version number")
7. Run script eng\pack.ps1 -Freeze        Recreate, and maybe publish the package
8. Publish package                        Only if not yet done

Post actions.
a. For production packages, git tag, then publish.
   > git tag vX.Y.Z
   or
   > git tag -a vX.Y.Z -m "Bla bla"
   then
   > git push origin vX.Y.Z
   Or do it within GitHub website.
   https://git-scm.com/book/en/v2/Git-Basics-Tagging
b. Update the page Releases on github.

Multi-targeting
---------------

For libraries, use
  <TargetFrameworks>$(LibraryPlatforms)</TargetFrameworks>
For test projects, use
  <TargetFrameworks>$(TestPlatforms)</TargetFrameworks>
Do not use "TargetFramework" (no "s"), otherwise testing multi-targets
at once won't work.
For exe projects, use
  <TargetFramework>$(DefaultPlatform)</TargetFramework>

First-class support is provided for
- .NET Standard   1.1   - 2.1
- .NET Core       2.1   - 3.1
- .NET Framework  4.5.2 - 4.8
Limited support is offered for
- .NET Core       2.0
- .NET Framework  4.5 - 4.5.1
These are targets no longer supported by Xunit runners. We kind of test
them but it's a bit convoluted (see "src\Abc.Tests\PackageReferences.targets")
and, to be honest, I am not even sure that we truely test v4.5/4.5.1
(see "test\Package").

In a smoke context (VS), we keep things as simple as possible.
- We target only **one** (concrete) platform, this is also required by
  - cover.ps1 (warning before generating the CC report).
  - Azure pipeline & GitHub action when DOTNET_MULTILEVEL_LOOKUP = 0.
- It should simply work on Windows, Linux and MacOS, no .NET Framework...
- It should only test the latest API profile.

| Library          | Test          | API     |
| ============= smoke context ============== |
| netstandard2.0   |               | v2.0    |
| netcoreapp3.1    | netcoreapp3.1 | v2.1    | <- DefaultPlatform
| ============ default context ============= |
| netstandard2.1   | netcoreapp3.1 | v2.1    |
| netstandard2.0   | netcoreapp2.1 | v2.0    |
| netstandard1.1   | net452        | v2.0    |
| net461           | net461        | v2.0    |

- The version in the column "Test" is the minimal LTS variant we can test
  (if there is an LTS version) and which implements the .NET Standard in
  the column "Library".
- "DefaultPlatform" should be the latest available platform supporting it,
  otherwise some CI builds will fail. See also "global.json".

If/when we add a third profile, we should revise this table.
Let's say that there is a new .NET Standard (vA.B) for which we wish to
define a new API profile and that we have three platforms (vX.0-X.2)
supporting it w/ vX.1 being LTS.

| Library          | Test          | API     |
| ============= smoke context ============== |
| netstandard2.0   |               | v2.0    |
| platformX.2      | platformX.2   | vA.B    | <- DefaultPlatform
| ============ default context ============= |
| netstandardA.B   | platformX.1   | vA.B    |
| netstandard2.1   | netcoreapp3.1 | v2.1    |
| netstandard2.0   | netcoreapp2.1 | v2.0    |
| netstandard1.1   | net452        | v2.0    |
| net461           | net461        | v2.0    |

API profile numbering schema:
- v2.0, for platforms preceding .NET Standard 2.1.
- v2.1, for platforms implementing .NET Standard 2.1.
- vA.B, for platforms implementing .NET Standard A.B.

Remarks:
- The first listed framework in "LibraryPlatforms" is the one used by the
  VS editor. Full NRT-analysis requires .NET Core 3.0 or above, .NET Standard
  does not include the nullable annotations (version 2.1 defines the nullable
  attributes but VS doesn't use them if I understand things correctly).
  We use the version 3.1 instead of 3.0 because the former is LTS and the
  latter is already EOL.
- "TestPlatforms", when testing on non-Windows OSes, we __ignore__ .NET
  Framework entirely, that is Mono.
- We add "net461" to avoid some issues with versions of the .NET Framework
  implementing .NET Standard 2.0 and preceding v4.7.2.
- Do NOT add .NET Standard 1.0, v1.1 has everything we need but with
  a much simpler dependency graph.
- .NET Framework (Classic).
  "MinClassicPlatforms" lists the last minor version of each major version.
  "MaxClassicPlatforms" must contain "MinClassicPlatforms".
- .NET Core.
  "MinCorePlatforms" lists the LTS versions and the latest one if not LTS.
  "MaxCorePlatforms" must contain "MinCorePlatforms".

API differences. We try to minimize them by defining only two "profiles" that
match exactly a .NET Standard version:
- Profile 2.1 for .NET Standard 2.1.
- Profile 2.0 for the platforms preceding it.
Profile 2.1 is a superset of Profile 2.0.
NB: attributes are NOT considered to be part of the API.

If there are, for say, things we could do w/ .NET Standard 2.1 but not w/
.NET Core 3.1, we have two cases:
- Use PlatformNotSupportedException for things that could be supported within in
  a given profile but are not actually.
- Simply do not do it if it can't be done, eg when a type would appear in the
  signature of a method only exists in one of the two platforms. This is
  actually what we do with Unit and the profile 2.0, we could support
  IEquatable<ValueTuple> but we don't because of ValueTuple.
  I could have added a dependency on System.ValueTuple (NuGet), but I prefer
  not to. I really do not want to add any dependency to our NuGet package.

References
- .NET Standard versions.
  https://dotnet.microsoft.com/platform/dotnet-standard#versions
  https://github.com/dotnet/standard/blob/master/docs/versions.md
- Target frameworks
  https://docs.microsoft.com/en-us/dotnet/standard/frameworks
- .NET Framework lifecycle.
  https://support.microsoft.com/en-us/help/17455/lifecycle-faq-net-framework
- .NET Core lifecycle.
  https://dotnet.microsoft.com/platform/support/policy/dotnet-core
  https://github.com/dotnet/core/blob/master/microsoft-support.md
- Useful docs.
  https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting
  https://docs.microsoft.com/en-us/dotnet/core/tutorials/libraries
  https://docs.microsoft.com/en-us/dotnet/core/packages

Compiler Symbols
----------------

In "D.B.targets".
- NETSTANDARD1_x
- NETCOREAPP2_x
- API_PROFILE_21
- CONTRACTS_FULL (standard symbol)

In "src\D.B.targets".
- SIGNED_ASSEMBLY
- INTERNALS_VISIBLE_TO
- UNCHECKED
- PATCH_EQUALITY

Project-specific symbols.
- VISIBLE_INTERNALS         in Abc.Maybe
- USE_ATTRS_FROM_ABC_MAYBE  in Abc.Testing
- BENCHMARK_HARNESS         in Abc.Performance.Tests

Development
-----------

Rules.
- Seal classes unless they are designed for extensibility.
- Add nullable annotations wherever necessary.
  Tag any use of the null-forgiving operator (!) with BONSANG!.
- Methods that return something should have the attribure Pure. It is not
  mandatory but it clearly states that the result should not be ignored.
  It might seem superfluous, but "Ã§a ne mange pas de pain".
- Good principles worth remembering: The Zen of Python.
  https://www.python.org/dev/peps/pep-0020/

Changes to the default editor config (does not affect the compilation).
- IDE0039 - csharp_style_pattern_local_over_anonymous_function
- IDE0060 - dotnet_code_quality_unused_parameters, (Remove unused parameter) covered by CA1801.
https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-language-conventions?view=vs-2019

From time to time, we should review our usage of
- #pragma warning disable
- #nullable disable
- SuppressMessage
- BONSANG! null-forgiving ("damnit") operator

Useful tools.
- NuGet Package Explorer
- ILDasm, ILSpy, dotPeek

Dump the test suite.
> dotnet test --list-tests

Source Link checks.
> dotnet sourcelink -h

Build
-----

MSBuild project files are __read__ in the following order:
1. Directory.Build.props
2. XXX.csproj
3. Directory.Build.targets
4. src\Directory.Build.targets
5. Retail.props (maybe)
6. XXX.props    (maybe)
7. src\XXX\Directory.Build.targets

Source Link.
We don't create a seperate symbols package. The PDB's are rather small, and it
works all the time (no need to configure the NuGet.org symbol server in VS).

Deterministic builds?
There are many side factors to take into account to ensure identical outputs
across compilations. For instance, the cwd may change depending on the build
machine. Anyway, deterministic build is the default MSBuild setting, and we
only check that NuGetPackageExplorer reports the package as deterministic.
Furthermore, we ensure that there are no uncommited changes before creating a
package.

One thing that is definitely non-deterministic is the attribute
"AssemblyFileVersion" as it may contain build/revision numbers that
are time-dependent, but this is entirely done prior to compilation, and therefore
can be easily reproduced afterwards.

References.
- https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink
- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/deterministic-compiler-option
- https://blog.paranoidcoding.com/2016/04/05/deterministic-builds-in-roslyn.html

CI
--

1. Smoke tests (GitHub).
   OS: Windows, Linux and MacOS.
   Settings: SmokeBuild=true.
   Configuration: Debug.
   Tasks: build then test the solution.

2. Testing + Code Coverage (AZP).
   OS: Windows.
   Settings: default.
   Configuration: Debug.
   Tasks: build then test the solution.

3. Packing then testing (AZP).
   OS: Windows, Linux and MacOS.
   Settings: Retail=true.
   Configuration: Release for packing, Debug for testing.
   Tasks: create a package then test it.

4. Build (AZP). Not automatically run.
   OS: Windows.
   Settings: Retail=true.
   Configuration: Debug.
   Tasks: build the solution for all supported platforms.

To skip CI on push,
- for AZP only, add [skip azp] to the commit message.
- for both AZP and GitHub Actions, add [skip ci] to the commit message.

References.
- https://chtoucas.visualstudio.com/Abc.Maybe/_build
- https://github.com/actions/virtual-environments

PowerShell
----------

Common script/function parameters:
   -NoDev
   -Reset
   -Restore
   -DryRun
   -Force
-f|-Platform
-c|-Configuration
-a|-AllXXX
-l|-ListXXX
-o|-Optimise
-y|-Yes
-v|-MyVerbose
-h|-Help

Common function parameters:
   -ExitOnError

Maintenance
-----------

> dotnet restore
> dotnet list package --outdated
> dotnet restore eng\NETFxTools
> dotnet list eng\NETFxTools package --outdated
> dotnet restore test\Performance.sln
> dotnet list test\Performance.sln package --outdated

.NET Framework tools (see "eng\NETFxTools"):
- OpenCover, used by cover.ps1
- xunit.runner.console, used by test-package.ps1

.NET Core (local) tools:
- ReportGenerator, used by cover.ps1
- SourceLink, not used by any script

There seems to be no built-in way to find outdated .NET Core tools, but
> dotnet tool update <packagename>
updates the tool with the latest stable version.
To find the <packagename>:
> dotnet tool list
Right now, we only have to do:
> dotnet tool update dotnet-reportgenerator-globaltool

To find outdated NuGet references in supporting projects:
> dotnet list test\NETSdk package --framework net48 --outdated
NB: these commands will fail if the package were not restored before.
NB: we used net48, but any other would do the job (and you can remove this).
NB: Project test\Blank has no external references.

Show / clear content of NuGet cache
> dotnet nuget locals all -l
> dotnet nuget locals all --clear

Misc
----

Strong named key.
To extract the public key, then get the public key.
> sn -p Abc.snk Abc.pk
> sn -tp Abc.pk

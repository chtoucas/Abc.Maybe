Developer Notes
===============

Minimal requirement: .NET Core 3.1.300

Versioning
----------

Format Major.Minor.Patch[-PreRelease]
- Major: Breaking changes -or- Major new features.
- Minor: Minor new features, but backwards compatible.
- Patch: Backwards compatible bug fixes only.
- PreRelease:
  alpha) Used for work-in-progress and experimentation.
  beta)  One that is feature complete for the next planned release, but may
         contain known bugs.
  rc)    A release that's potentially final (stable) unless significant bugs
         emerge.
Regarding new features, we do not follow exactly semantic versioning;
see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning

Under normal circumstances, we do NOT introduce breaking changes, in particular
we do NOT remove features (we mark them as obsolete).
If we have to, this can ONLY happen with a new MAJOR release (not minor), eg
1.3.4 to 2.0.0 is OK, but 1.3.4 to 1.4.0 is NOT.
Pre-releases are free to introduce new features and remove them after; it should
not happen with beta releases but we never know.

Changelog
---------

Sections.
- Added, for new features.
- Changed, for changes in existing functionality.
  Binary breaking changes MUST be prefixed w/ [BREAKING] and appeared first.
  New obsolete methods MUST be prefixed w/ [OBSOLETE] and appear just after.
- Removed, for now removed features. NB: any item appearing here obviously
  introduces a breaking change.
- Fixed, for any bug fixes.
- Security, in case of vulnerabilities.
- Internal Changes, for changes that are of no interest outside the project.

Production releases should have a title and highlight the relevant changes made
during the pre-release phase.

Inspired by https://keepachangelog.com/en/1.0.0/

References.
- https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/breaking-changes
- https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/breaking-change-rules.md
- https://stackoverflow.com/questions/1456785/a-definitive-guide-to-api-breaking-changes-in-net

Release Process
---------------

Requirement: command-line git.

Before a production packages, check that there are no remaining FIXMEs and review
the TODOs and REVIEWs.

Pre action, for beta -or- production packages.
0. Run script eng\freeze-api.ps1, then review the result.
   NB: between releases, feel free to add and remove **new** stuff.

1. New version in src\Abc.Maybe.props
2. Update CHANGELOG
3. Run eng\pack.ps1 -NoCI -y              Create the package
4. Run eng\test-package.ps1 -NoCI -a -y   Test the result
6. Git commit
7. Run script eng\pack.ps1 -Freeze        Recreate, and maybe publish the package
8. Publish package                        Only if not yet done

Post actions.
a. For production packages, git tag (??? before, to get the correct branch ???)
   https://git-scm.com/book/en/v2/Git-Basics-Tagging

Multi-targeting
---------------

Supported standards.
- .NET Standard 2.1
- .NET Standard 2.0    (NETSTANDARD2_0)
Supported platforms.
- .NET Framework 4.6.1 (NETFRAMEWORK)
  We use NETFRAMEWORK, not NET461, since this is the only .NET Framework version
  we intend to enable during build.
Inside VS, we only use .NET Standard 2.0 and .NET Core 3.1 (this one is added so
that we benefit from full NRT-analysis).

IMPORTANT, after adding or removing a framework, we must update
- Directory.Build.props (MaxApiPlatform)
- Directory.Build.targets (DefineConstants)
- Abc.Maybe.csproj (PublicAPI)
- qbuild.cmd
- pack.ps1

API differences. We try to minimize them by defining only two "profiles" that
match exactly a .NET Standard version:
- Profile 2.1 for .NET Standard 2.1
- Profile 2.0 for .NET Standard 2.0 & .NET Framework 4.6.1.
Profile 2.1 is a superset of Profile 2.0.
If we add a profile 2.2, it must be a superset of profile 2.1:
in Directory.Build.targets, both API_PROFILE_22 and API_PROFILE_21 are defined
for the new profile.
See https://github.com/dotnet/standard

If there are for say things we could do w/ .NET Standard 2.1 but not w/ .NET Core
3.1, we have two cases:
- Use PlatformNotSupportedException for things that could be supported within in
  a given profile but are not actually.
- Simply do not do it if it can't be done, eg when a type would appear in the
  signature of a method only exists in one of the two platforms. This is
  actually what we do with Unit and the profile 2.0, we could support
  IEquatable<ValueTuple> but we don't because of ValueTuple.
  I could have added a dependency on System.ValueTuple (NuGet), but I prefer
  not to. I really do not want to add any dependency to our NuGet package.

We only handle two special cases:
- NETSTANDARD2_0 || NETFRAMEWORK
  * Nullable attributes (added)
  * Span<> (disabled)
- NETFRAMEWORK
  * ValueTuple (disabled)
    Only available starting from .NET Framework 4.7.
  * Enumerable.Append and Enumerable.Prepend (added)
    Only available starting from .NET Framework 4.7.1.
  * Code Analysis warnings.
  * Test project:
    - String.GetHashCode(StringComparison) does not exist.
    - Enumerable.Empty<T>() is empty when cast to IList<T>.
      The result is null w/ .NET Standard or .NET Core.
    - DateTime parsing.

https://docs.microsoft.com/en-us/dotnet/standard/net-standard
https://dotnet.microsoft.com/platform/dotnet-standard
https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting

Development
-----------

Rules.
- Seal classes unless they are designed for extensibility.
- Add nullable annotations wherever necessary.
  Tag any use of the null-forgiving operator (!) with BONSANG!.
- Methods that return something should have the attribure Pure. It is not
  mandatory but it clearly states that the result should not be ignored.
  It might seem superfluous, but "Ã§a ne mange pas de pain".
- Good principles worth remembering: The Zen of Python.
  https://www.python.org/dev/peps/pep-0020/

Changes to the default editor config (does not affect the compilation).
- IDE0039 - csharp_style_pattern_local_over_anonymous_function
- IDE0060 - dotnet_code_quality_unused_parameters, (Remove unused parameter) covered by CA1801.
https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-language-conventions?view=vs-2019

From time to time, we should review our usage of
- #pragma warning disable
- #nullable disable
- SuppressMessage
- BONSANG! null-forgiving ("damnit") operator

Useful tools.
- NuGet Package Explorer
- ILDasm, ILSpy, dotPeek

Build
-----

MSBuild project files are __read__ in the following order:
1. Directory.Build.props
2. XXX.csproj
3. Directory.Build.targets
4. Retail.props (maybe)
5. XXX.props    (maybe)
6. src\Directory.Build.targets

Tools
-----

Common script/function parameters:
   -NoCI
   -Reset
   -Restore
   -DryRun
   -Force
-a|-AllXXX
-l|-ListXXX
-o|-Optimise
-y|-Yes
-v|-MyVerbose
-h|-Help

Common function parameters:
   -ExitOnError

Maintenance
-----------

> dotnet restore
> dotnet list package --outdated
> dotnet list eng\NETFrameworkTools package --outdated

.NET Framework tools (see "eng\NETFrameworkTools"):
- OpenCover, used by cover.ps1
- xunit.runner.console, used by test-package.ps1

.NET Core (local) tools:
- ReportGenerator, used by cover.ps1

There seems to be no built-in way to find outdated .NET Core tools, but
> dotnet tool update <packagename>
updates the tool with the latest stable version.
To find the <packagename>:
> dotnet tool list
Right now, we only have to do:
> dotnet tool update dotnet-reportgenerator-globaltool

To find outdated NuGet references in supporting projects:
> dotnet list test\NETSdk package --framework net48 --outdated
NB: these commands will fail if the package were not restored before.
NB: we used net48, but any other would do the job (and you can remove this).
NB: Project test\Blank has no external references.

Show / clear content of NuGet cache
> dotnet nuget locals all -l
> dotnet nuget locals all --clear

Strong named key
----------------

To extract the public key, then get the public key.
> sn -p Abc.snk Abc.pk
> sn -tp Abc.pk

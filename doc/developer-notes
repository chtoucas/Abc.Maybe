Developer Notes
===============

Versioning
----------

Format Major.Minor.Patch[-PreRelease]
- Major: Breaking changes -or- Major new features.
- Minor: Minor new features, but backwards compatible.
- Patch: Backwards compatible bug fixes only.
- PreRelease:
  DEV)   Internal, not for public consumption.
         Exist only to prevent accidental publication of a dev package.
  alpha) Used for work-in-progress and experimentation.
  beta)  One that is feature complete for the next planned release, but may
         contain known bugs.
  rc)    A release that's potentially final (stable) unless significant bugs
         emerge.
Regarding new features, we do not follow exactly semantic versioning;
see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning

Under normal circumstances, we do NOT introduce breaking changes, in particular
we do NOT remove features (we mark them as obsolete).
If we have to, this can ONLY happen with a new MAJOR release (not minor), eg
1.3.4 to 2.0.0 is OK, but 1.3.4 to 1.4.0 is NOT.
Pre-releases are free to introduce new features and remove them after; it should
not happen with beta releases but we never know.

Changelog
---------

Sections.
- Added, for new features.
- Changed, for changes in existing functionality.
  Binary breaking changes MUST be prefixed w/ [BREAKING] and appeared first.
  New obsolete methods MUST be prefixed w/ [OBSOLETE] and appear just after.
- Removed, for now removed features. NB: any item appearing here obviously
  introduces a breaking change.
- Fixed, for any bug fixes.
- Security, in case of vulnerabilities.
- Internal Changes, for changes that are of no interest outside the project.

Production releases should have a title and highlight the relevant changes made
during the pre-release phase.

Inspired by https://keepachangelog.com/en/1.0.0/

Release Process
---------------

Requirement: command-line git.

Before a production packages, check that there are no remaining FIXMEs and review
the TODOs and REVIEWs.

Pre action, for beta -or- production packages.
0. Run script eng\freeze-api.ps1, then review the result.
   NB: between releases, feel free to add and remove **new** stuff.

1. New version in eng\Abc.Maybe.props
2. Update CHANGELOG
3. Run script eng\pack.ps1 -n -f
4. Git commit
5. Run script eng\pack.ps1 -c -s
6. Publish package

Post action, for production packages.
6. Git tag (??? before, to get the correct tag ???)

Multi-targeting
---------------

Supported frameworks.
- .NET Core 3.1
- .NET Standard 2.1
- .NET Standard 2.0    (NETSTANDARD2_0)
- .NET Framework 4.6.1 (NETFRAMEWORK)
  We use NETFRAMEWORK, not NET461, since this is the only .NET Framework version
  we intend to enable during build.
Inside VS, we only use .NET Standard 2.0 and .NET Core 3.1 (this one is added so
that we benefit from full NRT-analysis).

IMPORTANT, after adding or removing a framework, we must update
- the project files, Directory.Build.props
  don't forget PublicAPI within Abc.Maybe.csproj
- qbuild.cmd
- qtest.cmd
- reset.ps1
- pack.ps1

API differences. We try to minimize them by defining only two "profiles":
- Maximal API for .NET Standard 2.1 & .NET Core 3.1.
- Minimal API for .NET Standard 2.0 & .NET Framework 4.6.1.
The Maximal API is a superset of Minimal one.

If there are for say things we could do w/ .NET Standard 2.1 but not w/ .NET Core
3.1, we have two cases:
- use PlatformNotSupportedException for things that could be supported within in
  a given profile but are not actually.
- simply do not do it if it can't be done, eg when a type would appear in the
  signature of a method only exists in one of the two platforms. This is
  actually what we do with Unit and the Min profile, we could support
  IEquatable<ValueTuple> but we don't because of ValueTuple.
  I could have added a dependency on System.ValueTuple (NuGet), but I prefer
  not to. I really do not want to add any dependency to our NuGet package.

We only handle two special cases:
- NETSTANDARD2_0 || NETFRAMEWORK
  * Nullable attributes (added)
  * Span<> (disabled)
- NETFRAMEWORK
  * ValueTuple (disabled)
    Only available starting from .NET Framework 4.7.
  * Enumerable.Append and Enumerable.Prepend (added)
    Only available starting from .NET Framework 4.7.1.
  * Code Analysis warnings.
  * Test project:
    - String.GetHashCode(StringComparison) does not exist.
    - Enumerable.Empty<T>() is empty when cast to IList<T>.
      The result is null w/ .NET Standard or .NET Core.
    - DateTime parsing.

Minimal supported platforms
- .NET Standard     2.0         (2.0, 2.1)
- .NET Core         2.0         (3.1)
- .NET Framework    4.6.1       (4.6.1)
- Mono              5.4
- Xamarin.iOS       10.14
- Xamarin.Mac       3.8
- Xamarin.Android   8.0
- UWP               10.0.16299
- Unity             2018.1
Between parenthesis we give the versions we explicitly ship with the NuGet
package. For instance, we have full support for .NET Core 2.0-3.0 "indirectly"
via .NET Standard 2.0, and directly for .NET Core 3.1.
See https://docs.microsoft.com/en-us/dotnet/standard/net-standard

https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting

Development
-----------

Rules.
- Seal classes unless they are designed for extensibility.
- Add nullable annotations wherever necessary.
  Tag any use of the null-forgiving operator (!) with BONSANG!.
- Methods that return something should have the attribure Pure. It is not
  mandatory but it clearly states that the result should not be ignored.
  It might seem superfluous, but "Ã§a ne mange pas de pain".
- Good principles worth remembering: The Zen of Python.
  https://www.python.org/dev/peps/pep-0020/

Changes to the default editor config (does not affect the compilation).
- IDE0039 - csharp_style_pattern_local_over_anonymous_function
- IDE0060 - dotnet_code_quality_unused_parameters, (Remove unused parameter) covered by CA1801.
https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-language-conventions?view=vs-2019

From time to time, we should review our usage of
- #pragma warning disable
- #nullable disable
- SuppressMessage
- BONSANG! null-forgiving ("damnit") operator

Local tools (in eng).
- qtest.cmd, run the test suite.
- qperf.cmd, run the perf tool.
- qbuild.cmd, build project/solution for all supported frameworks.
- dump-test-suite.cmd, dump the test suite.
- cover.ps1, code coverage script (Coverlet or OpenCover).
- pack.ps1, packing script.
- freeze-api.ps1, update public API files.

Useful tools.
- NuGet Package Explorer
- ILDasm, ILSpy, dotPeek

Tests
-----

- Do not hesitate to test the obvious and to write redundant tests.
- Test what's not supposed to work too, eg misuses.
- Tests should provide samples.

Naming tests and grouping them are here to help us to find the relevant test
cases and, more importantly, spot the missing ones. The only real rule is that
what does a test should be easily understandable from the name.
Anyway, in general, we use the following pattern for unit tests:
- Property or method name, followed by
- Instance, followed by
- Expectation, followed by
- "With" for parameters, followed by
- "For" for generic parameters, followed by
- "When" for specific conditions

Testing with or without NRTs
- T : notnull
- T? where T : class
Postfix the test method with _WithoutNRTs.
Prefer Assert.Equal() to Assert.Some()/None(); we want to see the return type.
Instead of using a #pragma to disable the warnings
- CS8600 Converting null literal or possible null value to non-nullable type
- CS8620  Argument cannot be used for parameter due to differences in the nullability of reference types.
- CS8714  The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.
I prefer to use the #nullable driective to disable annotations or warnings (this
is more explicit about what's going on).
These tests are really unnecessary, but I wish to see the methods at work in a
context where NRTs is disabled and ensure that they truely make sense.
